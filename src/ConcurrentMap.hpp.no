#include <unordered_map>
#include <utility>
#include <mutex>


template <typename Key, typename Value>
class ConcurrentMap {
private:
  struct LockedValue {
    Value val_;
    std::mutex valMutex_;

    const LockedValue& operator=(const LockedValue& other) {
      std::lock_guard<std::mutex> guard(valMutex_);
      val_ = other;
    }
  };

public:
  ConcurrentMap(size_t hashSpace) : 

  bool erase(const Key& key);
  bool insert(const Key& key, const Value& value);


private:
  std::vector<std::mutex> locks_;
  std::unordered_map<Key, LockedValue> container_;
  std::mutex globalLock_;
  


  // Types of locks:
  //  Global write lock -> on erase, lock the whole container
  //  Record lock -> on modifying a value we need to lock that value alone
  //  Reads -> no lock needed (https://en.cppreference.com/w/cpp/container#Thread_safety) 

  // What we need in the cache: erase, (find) isMember, end, size, []
  // we can re-write to have erase and insert only
};

template <typename Key, typename Value>
bool ConcurrentMap<Key, Value>::erase(const Key& key) {
  /**
  * References and iterators to the erased elements are invalidated. Other
  * iterators and references are not invalidated.
  *
  * The iterator pos must be valid and dereferenceable. Thus the end()
  * iterator (which is valid, but is not dereferenceable) cannot be used as a
  * value for pos.
  *
  * The order of the elements that are not erased is preserved. (This makes it
  * possible to erase individual elements while iterating through the container.)
  */

  auto &it = container_.find(key);

  if (it == container_.end()) {
    return false;
  }

  std::lock_guard<std::mutex> guard(it->valMutex_);
  // At this point the element at 'it' could have been deleted by another
  // thread. No problem, erase should not throw in such case.
  container_.erase(it);
  return true;
}

template <typename Key, typename Value>
bool ConcurrentMap<Key, Value>::insert(const Key& key, const Value& value) {

}


